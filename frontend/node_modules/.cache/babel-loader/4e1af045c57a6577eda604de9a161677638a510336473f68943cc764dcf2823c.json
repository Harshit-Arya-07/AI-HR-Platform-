{"ast":null,"code":"import { api } from './authService';\nclass CandidateService {\n  // Extract text from PDF file\n  async extractPDFText(file) {\n    return new Promise((resolve, reject) => {\n      const reader = new FileReader();\n      reader.onload = async e => {\n        try {\n          var _e$target;\n          // For now, we'll use a simple text extraction\n          // In a real implementation, you'd use a PDF parsing library like pdf-lib or PDF.js\n          const text = (_e$target = e.target) === null || _e$target === void 0 ? void 0 : _e$target.result;\n\n          // Simple text extraction - in production, use proper PDF parsing\n          if (file.type === 'application/pdf') {\n            // This is a placeholder - in reality you'd need PDF.js or similar\n            reject(new Error('PDF parsing requires additional setup. Please copy and paste resume text for now.'));\n          } else {\n            // Handle text files\n            resolve(text);\n          }\n        } catch (error) {\n          reject(error);\n        }\n      };\n      if (file.type === 'application/pdf') {\n        reader.readAsArrayBuffer(file);\n      } else {\n        reader.readAsText(file);\n      }\n    });\n  }\n\n  // Create candidate with resume processing\n  async createCandidate(data) {\n    try {\n      const response = await api.post('/api/candidates', data);\n      return response.data;\n    } catch (error) {\n      var _error$response, _error$response$data;\n      throw new Error(((_error$response = error.response) === null || _error$response === void 0 ? void 0 : (_error$response$data = _error$response.data) === null || _error$response$data === void 0 ? void 0 : _error$response$data.message) || 'Failed to create candidate');\n    }\n  }\n\n  // Upload resume file and create candidate\n  async uploadResume(file, jobId, candidateInfo) {\n    try {\n      const resumeText = await this.extractPDFText(file);\n      return await this.createCandidate({\n        resumeText,\n        jobId,\n        ...candidateInfo\n      });\n    } catch (error) {\n      throw new Error(error.message || 'Failed to upload resume');\n    }\n  }\n\n  // Get all candidates with filters\n  async getCandidates(filters) {\n    try {\n      const params = new URLSearchParams();\n      if (filters) {\n        Object.entries(filters).forEach(([key, value]) => {\n          if (value !== undefined && value !== null) {\n            params.append(key, value.toString());\n          }\n        });\n      }\n      const response = await api.get(`/api/candidates?${params.toString()}`);\n      return response.data;\n    } catch (error) {\n      var _error$response2, _error$response2$data;\n      throw new Error(((_error$response2 = error.response) === null || _error$response2 === void 0 ? void 0 : (_error$response2$data = _error$response2.data) === null || _error$response2$data === void 0 ? void 0 : _error$response2$data.message) || 'Failed to fetch candidates');\n    }\n  }\n\n  // Update candidate status\n  async updateCandidateStatus(id, status, notes) {\n    try {\n      const response = await api.patch(`/api/candidates/${id}/status`, {\n        status,\n        notes\n      });\n      return response.data;\n    } catch (error) {\n      var _error$response3, _error$response3$data;\n      throw new Error(((_error$response3 = error.response) === null || _error$response3 === void 0 ? void 0 : (_error$response3$data = _error$response3.data) === null || _error$response3$data === void 0 ? void 0 : _error$response3$data.message) || 'Failed to update candidate status');\n    }\n  }\n}\nexport const candidateService = new CandidateService();","map":{"version":3,"names":["api","CandidateService","extractPDFText","file","Promise","resolve","reject","reader","FileReader","onload","e","_e$target","text","target","result","type","Error","error","readAsArrayBuffer","readAsText","createCandidate","data","response","post","_error$response","_error$response$data","message","uploadResume","jobId","candidateInfo","resumeText","getCandidates","filters","params","URLSearchParams","Object","entries","forEach","key","value","undefined","append","toString","get","_error$response2","_error$response2$data","updateCandidateStatus","id","status","notes","patch","_error$response3","_error$response3$data","candidateService"],"sources":["D:/Projects/AI Resumer/frontend/src/services/candidateService.ts"],"sourcesContent":["import { api } from './authService';\r\n\r\nexport interface Candidate {\r\n  _id: string;\r\n  name: string;\r\n  email: string;\r\n  phone?: string;\r\n  resumeText: string;\r\n  jobId: string;\r\n  overallScore: number;\r\n  scoreBreakdown: {\r\n    skillOverlap: number;\r\n    semanticSimilarity: number;\r\n    roleRelevance: number;\r\n    seniorityMatch: number;\r\n  };\r\n  extractedSkills: string[];\r\n  missingSkills: string[];\r\n  aiSummary: string;\r\n  recommendation: 'STRONG_MATCH' | 'GOOD_MATCH' | 'AVERAGE_MATCH' | 'WEAK_MATCH';\r\n  confidence: number;\r\n  interviewQuestions: string[];\r\n  status: 'new' | 'reviewed' | 'interviewing' | 'hired' | 'rejected';\r\n  createdAt: string;\r\n  updatedAt: string;\r\n}\r\n\r\nexport interface CreateCandidateData {\r\n  resumeText: string;\r\n  jobId: string;\r\n  name?: string;\r\n  email?: string;\r\n  phone?: string;\r\n}\r\n\r\nexport interface CandidatesResponse {\r\n  candidates: Candidate[];\r\n  pagination: {\r\n    total: number;\r\n    page: number;\r\n    pages: number;\r\n    limit: number;\r\n  };\r\n}\r\n\r\nclass CandidateService {\r\n  // Extract text from PDF file\r\n  async extractPDFText(file: File): Promise<string> {\r\n    return new Promise((resolve, reject) => {\r\n      const reader = new FileReader();\r\n      reader.onload = async (e) => {\r\n        try {\r\n          // For now, we'll use a simple text extraction\r\n          // In a real implementation, you'd use a PDF parsing library like pdf-lib or PDF.js\r\n          const text = e.target?.result as string;\r\n          \r\n          // Simple text extraction - in production, use proper PDF parsing\r\n          if (file.type === 'application/pdf') {\r\n            // This is a placeholder - in reality you'd need PDF.js or similar\r\n            reject(new Error('PDF parsing requires additional setup. Please copy and paste resume text for now.'));\r\n          } else {\r\n            // Handle text files\r\n            resolve(text);\r\n          }\r\n        } catch (error) {\r\n          reject(error);\r\n        }\r\n      };\r\n      \r\n      if (file.type === 'application/pdf') {\r\n        reader.readAsArrayBuffer(file);\r\n      } else {\r\n        reader.readAsText(file);\r\n      }\r\n    });\r\n  }\r\n\r\n  // Create candidate with resume processing\r\n  async createCandidate(data: CreateCandidateData): Promise<{ message: string; candidate: Candidate }> {\r\n    try {\r\n      const response = await api.post('/api/candidates', data);\r\n      return response.data;\r\n    } catch (error: any) {\r\n      throw new Error(error.response?.data?.message || 'Failed to create candidate');\r\n    }\r\n  }\r\n\r\n  // Upload resume file and create candidate\r\n  async uploadResume(file: File, jobId: string, candidateInfo?: { name?: string; email?: string; phone?: string }): Promise<{ message: string; candidate: Candidate }> {\r\n    try {\r\n      const resumeText = await this.extractPDFText(file);\r\n      \r\n      return await this.createCandidate({\r\n        resumeText,\r\n        jobId,\r\n        ...candidateInfo\r\n      });\r\n    } catch (error: any) {\r\n      throw new Error(error.message || 'Failed to upload resume');\r\n    }\r\n  }\r\n\r\n  // Get all candidates with filters\r\n  async getCandidates(filters?: {\r\n    jobId?: string;\r\n    status?: string;\r\n    minScore?: number;\r\n    maxScore?: number;\r\n    limit?: number;\r\n    skip?: number;\r\n  }): Promise<CandidatesResponse> {\r\n    try {\r\n      const params = new URLSearchParams();\r\n      if (filters) {\r\n        Object.entries(filters).forEach(([key, value]) => {\r\n          if (value !== undefined && value !== null) {\r\n            params.append(key, value.toString());\r\n          }\r\n        });\r\n      }\r\n\r\n      const response = await api.get(`/api/candidates?${params.toString()}`);\r\n      return response.data;\r\n    } catch (error: any) {\r\n      throw new Error(error.response?.data?.message || 'Failed to fetch candidates');\r\n    }\r\n  }\r\n\r\n  // Update candidate status\r\n  async updateCandidateStatus(id: string, status: string, notes?: string): Promise<{ message: string; candidate: Candidate }> {\r\n    try {\r\n      const response = await api.patch(`/api/candidates/${id}/status`, { status, notes });\r\n      return response.data;\r\n    } catch (error: any) {\r\n      throw new Error(error.response?.data?.message || 'Failed to update candidate status');\r\n    }\r\n  }\r\n}\r\n\r\nexport const candidateService = new CandidateService();"],"mappings":"AAAA,SAASA,GAAG,QAAQ,eAAe;AA6CnC,MAAMC,gBAAgB,CAAC;EACrB;EACA,MAAMC,cAAcA,CAACC,IAAU,EAAmB;IAChD,OAAO,IAAIC,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAK;MACtC,MAAMC,MAAM,GAAG,IAAIC,UAAU,CAAC,CAAC;MAC/BD,MAAM,CAACE,MAAM,GAAG,MAAOC,CAAC,IAAK;QAC3B,IAAI;UAAA,IAAAC,SAAA;UACF;UACA;UACA,MAAMC,IAAI,IAAAD,SAAA,GAAGD,CAAC,CAACG,MAAM,cAAAF,SAAA,uBAARA,SAAA,CAAUG,MAAgB;;UAEvC;UACA,IAAIX,IAAI,CAACY,IAAI,KAAK,iBAAiB,EAAE;YACnC;YACAT,MAAM,CAAC,IAAIU,KAAK,CAAC,mFAAmF,CAAC,CAAC;UACxG,CAAC,MAAM;YACL;YACAX,OAAO,CAACO,IAAI,CAAC;UACf;QACF,CAAC,CAAC,OAAOK,KAAK,EAAE;UACdX,MAAM,CAACW,KAAK,CAAC;QACf;MACF,CAAC;MAED,IAAId,IAAI,CAACY,IAAI,KAAK,iBAAiB,EAAE;QACnCR,MAAM,CAACW,iBAAiB,CAACf,IAAI,CAAC;MAChC,CAAC,MAAM;QACLI,MAAM,CAACY,UAAU,CAAChB,IAAI,CAAC;MACzB;IACF,CAAC,CAAC;EACJ;;EAEA;EACA,MAAMiB,eAAeA,CAACC,IAAyB,EAAsD;IACnG,IAAI;MACF,MAAMC,QAAQ,GAAG,MAAMtB,GAAG,CAACuB,IAAI,CAAC,iBAAiB,EAAEF,IAAI,CAAC;MACxD,OAAOC,QAAQ,CAACD,IAAI;IACtB,CAAC,CAAC,OAAOJ,KAAU,EAAE;MAAA,IAAAO,eAAA,EAAAC,oBAAA;MACnB,MAAM,IAAIT,KAAK,CAAC,EAAAQ,eAAA,GAAAP,KAAK,CAACK,QAAQ,cAAAE,eAAA,wBAAAC,oBAAA,GAAdD,eAAA,CAAgBH,IAAI,cAAAI,oBAAA,uBAApBA,oBAAA,CAAsBC,OAAO,KAAI,4BAA4B,CAAC;IAChF;EACF;;EAEA;EACA,MAAMC,YAAYA,CAACxB,IAAU,EAAEyB,KAAa,EAAEC,aAAiE,EAAsD;IACnK,IAAI;MACF,MAAMC,UAAU,GAAG,MAAM,IAAI,CAAC5B,cAAc,CAACC,IAAI,CAAC;MAElD,OAAO,MAAM,IAAI,CAACiB,eAAe,CAAC;QAChCU,UAAU;QACVF,KAAK;QACL,GAAGC;MACL,CAAC,CAAC;IACJ,CAAC,CAAC,OAAOZ,KAAU,EAAE;MACnB,MAAM,IAAID,KAAK,CAACC,KAAK,CAACS,OAAO,IAAI,yBAAyB,CAAC;IAC7D;EACF;;EAEA;EACA,MAAMK,aAAaA,CAACC,OAOnB,EAA+B;IAC9B,IAAI;MACF,MAAMC,MAAM,GAAG,IAAIC,eAAe,CAAC,CAAC;MACpC,IAAIF,OAAO,EAAE;QACXG,MAAM,CAACC,OAAO,CAACJ,OAAO,CAAC,CAACK,OAAO,CAAC,CAAC,CAACC,GAAG,EAAEC,KAAK,CAAC,KAAK;UAChD,IAAIA,KAAK,KAAKC,SAAS,IAAID,KAAK,KAAK,IAAI,EAAE;YACzCN,MAAM,CAACQ,MAAM,CAACH,GAAG,EAAEC,KAAK,CAACG,QAAQ,CAAC,CAAC,CAAC;UACtC;QACF,CAAC,CAAC;MACJ;MAEA,MAAMpB,QAAQ,GAAG,MAAMtB,GAAG,CAAC2C,GAAG,CAAC,mBAAmBV,MAAM,CAACS,QAAQ,CAAC,CAAC,EAAE,CAAC;MACtE,OAAOpB,QAAQ,CAACD,IAAI;IACtB,CAAC,CAAC,OAAOJ,KAAU,EAAE;MAAA,IAAA2B,gBAAA,EAAAC,qBAAA;MACnB,MAAM,IAAI7B,KAAK,CAAC,EAAA4B,gBAAA,GAAA3B,KAAK,CAACK,QAAQ,cAAAsB,gBAAA,wBAAAC,qBAAA,GAAdD,gBAAA,CAAgBvB,IAAI,cAAAwB,qBAAA,uBAApBA,qBAAA,CAAsBnB,OAAO,KAAI,4BAA4B,CAAC;IAChF;EACF;;EAEA;EACA,MAAMoB,qBAAqBA,CAACC,EAAU,EAAEC,MAAc,EAAEC,KAAc,EAAsD;IAC1H,IAAI;MACF,MAAM3B,QAAQ,GAAG,MAAMtB,GAAG,CAACkD,KAAK,CAAC,mBAAmBH,EAAE,SAAS,EAAE;QAAEC,MAAM;QAAEC;MAAM,CAAC,CAAC;MACnF,OAAO3B,QAAQ,CAACD,IAAI;IACtB,CAAC,CAAC,OAAOJ,KAAU,EAAE;MAAA,IAAAkC,gBAAA,EAAAC,qBAAA;MACnB,MAAM,IAAIpC,KAAK,CAAC,EAAAmC,gBAAA,GAAAlC,KAAK,CAACK,QAAQ,cAAA6B,gBAAA,wBAAAC,qBAAA,GAAdD,gBAAA,CAAgB9B,IAAI,cAAA+B,qBAAA,uBAApBA,qBAAA,CAAsB1B,OAAO,KAAI,mCAAmC,CAAC;IACvF;EACF;AACF;AAEA,OAAO,MAAM2B,gBAAgB,GAAG,IAAIpD,gBAAgB,CAAC,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}